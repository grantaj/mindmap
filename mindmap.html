<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="stylesheet" href="styles.css">
    <meta charset="UTF-8">
    <title>Mind Map Creator</title>
</head>

<body>
    <div id="appContainer">
        <div id="mindMapContainer" onwheel="zoomHandler(event)">
            <div id="mindMap">
                <svg></svg>
            </div>
        </div>
    </div>
</body>
<div id="controls">
    <div class="button-group">
        <button id="add">Add</button>
        <button id="connect">Connect</button>
        <button id="delete">Delete</button>
    </div>
    <div class="button-group right">
        <button onclick="exportToPDF()">Export PDF</button>
        <button onclick="exportToJson()">Save JSON</button>
        <button onclick="importFromJson()">Load JSON</button>
    </div>
</div>

<button id="helpButton">Help</button>
<div id="helpSidebar" class="sidebar">
    <button id="closeSidebar">Close</button>
    <h2>Instructions</h2>
    <p>This app lets you build mind maps:</p>
    <ul>
        <li>Click "Add" to enter Add Node Mode. Add nodes by clicking on the canvas.</li>
        <li>Click "Connect" to enter Connect Mode. Connect two nodes by clicking on them.</li>
        <li>Click "Delete" to enter Delete Node Mode. Delete nodes by clicking on them.</li>
        <li>Clicking again on the active button enters Edit Mode. Drag nodes to move, click on title or body text to
            edit.</li>
        <li>"Export PDF" button saves the mindmap as a PDF for easy sharing and printing.</li>
        <li>"Save JSON" and "Load JSON" buttons allow you to save and load your mind maps as structured JSON data.</li>
    </ul>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.2/html2canvas.min.js"></script>

<script>
    let selectedNode = null;
    //let isConnectionMode = false;
    let currentMode = 'edit';  // Possible values: 'add', 'connect', 'edit'

    const svg = document.querySelector('svg');
    const nodeConnections = new Map();
    const statusLine = document.getElementById('statusLine');
    const mindMap = document.getElementById('mindMap');

    document.addEventListener('DOMContentLoaded', function () {
        toggleMode('edit');
        //statusLine.textContent = 'Edit Node Mode';
        //statusLine.className = 'editNodeMode'; // Set default mode on page load
    });

    document.getElementById('add').addEventListener('click', function () {
        toggleMode('add');
    });

    document.getElementById('connect').addEventListener('click', function () {
        toggleMode('connect');
    });

    document.getElementById('delete').addEventListener('click', function () {
        toggleMode('delete');
    });

    document.getElementById('helpButton').addEventListener('click', function () {
        document.getElementById('helpSidebar').style.width = "250px";  // Set width to show sidebar
    });

    document.getElementById('closeSidebar').addEventListener('click', function () {
        document.getElementById('helpSidebar').style.width = "0";  // Set width to hide sidebar
    });


    mindMap.addEventListener('click', function (event) {
        if (currentMode === 'add') {
            const x = event.offsetX;
            const y = event.offsetY;
            createNode("Title", "Body", x + "px", y + "px", "node_" + Date.now());
        }
    });




    function nodeClickHandler(event) {
        event.stopPropagation();
        if (currentMode === 'delete') {
            deleteNode(event.target);
        } else if (currentMode === 'connect' && selectedNode) {
            if (selectedNode !== this) {
                drawLine(selectedNode, this);
                selectedNode.classList.remove('active');
                selectedNode = null;
            }
        } else if (currentMode === 'connect') {
            selectedNode = this;
            selectedNode.classList.add('active');
        }
    }

    function toggleMode(newMode) {
        const previouslyActive = document.querySelector('button.active');
        if (previouslyActive) {
            previouslyActive.classList.remove('active');
        }

        if (currentMode === newMode) {
            currentMode = 'edit';  // Deactivate current mode if it's re-toggled
        } else {
            currentMode = newMode;
            const modeButton = document.getElementById(newMode);
            modeButton.classList.add('active'); // Set the button as active
            if (newMode === 'add') {
                if (selectedNode) {
                    selectedNode.classList.remove('active');
                    selectedNode = null;
                }
            }
        }
    }


    function handleDragEnd(event) {
        this.style.left = event.pageX - mindMap.offsetLeft + 'px';
        this.style.top = event.pageY - mindMap.offsetTop + 'px';
        updateLines(this);
    }

    function drawLine(from, to) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        updateLineCoordinates(line, from, to);
        line.setAttribute('stroke', 'black');
        svg.appendChild(line);
        nodeConnections.get(from).push({ line: line, otherNode: to });
    }

    function updateLineCoordinates(line, from, to) {
        const x1 = from.offsetLeft + from.offsetWidth / 2;
        const y1 = from.offsetTop + from.offsetHeight / 2;
        const x2 = to.offsetLeft + to.offsetWidth / 2;
        const y2 = to.offsetTop + to.offsetHeight / 2;
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
    }

    function updateLines(node) {
        const connections = nodeConnections.get(node);
        connections.forEach(connection => {
            updateLineCoordinates(connection.line, node, connection.otherNode);
        });
    }

    function exportToJson() {
        let nodes = [];
        document.querySelectorAll('.node').forEach(node => {
            nodes.push({
                id: node.id,
                title: node.querySelector('.title').textContent,
                body: node.querySelector('.body').textContent,
                position: { x: node.style.left, y: node.style.top }
            });
        });

        let connections = [];
        nodeConnections.forEach((connectionsArray, node) => {
            // Ensure 'node' has a valid 'id' and connectionsArray is populated
            if (node.id && connectionsArray.length) {
                connections.push({
                    from: node.id,
                    to: connectionsArray.map(conn => conn.otherNode.id)  // Mapping to ids of connected nodes
                });
            }
        });

        const jsonData = JSON.stringify({ nodes, connections }, null, 2);  // Added null, 2 for pretty-printing JSON
        const blob = new Blob([jsonData], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'mindMap.json';
        link.click();
    }


    function importFromJson() {
        const input = document.createElement('input');
        input.type = 'file';
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = function (event) {
                const data = JSON.parse(event.target.result);
                rebuildMindMap(data);
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function rebuildMindMap(data) {
        const mindMap = document.getElementById('mindMap');

        // Remove all children except the SVG
        let child = mindMap.firstChild;
        while (child) {
            const nextChild = child.nextSibling; // Get the next child before potentially removing the current child
            if (child.tagName !== 'svg') {
                mindMap.removeChild(child);
            } else {
                // Clear SVG contents but keep the element
                child.innerHTML = '';
            }
            child = nextChild; // Move to the next child
        }

        const newNodesById = {};
        nodeConnections.clear(); // Clear existing connections

        // Rebuild nodes
        data.nodes.forEach(node => {
            const newNode = createNode(node.title, node.body, node.position.x, node.position.y, node.id);
            newNodesById[node.id] = newNode;
        });

        // Restore connections
        data.connections.forEach(connection => {
            const fromNode = newNodesById[connection.from];
            connection.to.forEach(toId => {
                const toNode = newNodesById[toId];
                if (fromNode && toNode) {
                    drawLine(fromNode, toNode);
                }
            });
        });
    }

    function exportToPDF() {
        const element = document.getElementById('mindMap'); // Adjust this to your specific element
        html2canvas(element).then(canvas => {
            const imgData = canvas.toDataURL('image/png');
            const pdf = new jspdf.jsPDF({
                orientation: 'landscape',
                unit: 'px',
                format: [canvas.width, canvas.height]
            });
            pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
            pdf.save('mind-map.pdf');
        });
    }


    function createNode(titleText, bodyText, posX, posY, id) {
        const node = document.createElement("div");
        node.classList.add("node");
        node.style.position = 'absolute';
        node.style.left = posX;
        node.style.top = posY;

        const title = document.createElement("div");
        title.className = 'title';
        title.contentEditable = true;
        title.textContent = titleText;
        node.appendChild(title);

        const body = document.createElement("div");
        body.className = 'body';
        body.contentEditable = true;
        body.textContent = bodyText;
        node.appendChild(body);

        node.draggable = true;
        node.ondragend = handleDragEnd;
        node.addEventListener('click', nodeClickHandler); // Reattach event handler
        node.id = id;
        nodeConnections.set(node, []);
        mindMap.appendChild(node);
        return node;
    }

    function deleteNode(node) {
        // Remove connections first
        if (nodeConnections.has(node)) {
            nodeConnections.get(node).forEach(conn => {
                conn.line.parentNode.removeChild(conn.line); // Remove the line from SVG
            });
            nodeConnections.delete(node); // Remove node entry from map
        }

        // Also remove connections from other connected nodes
        nodeConnections.forEach((connections, otherNode) => {
            nodeConnections.set(otherNode, connections.filter(conn => conn.otherNode !== node));
        });

        // Finally, remove the node itself
        node.parentNode.removeChild(node);
    }

    let scale = 1; // Initial scale

    function zoomHandler(event) {
        event.preventDefault();
        const zoomIntensity = 0.1;
        const mindMap = document.getElementById('mindMap');

        // Calculate zoom factor
        const direction = event.deltaY < 0 ? 1 : -1;
        scale *= (1 + direction * zoomIntensity);
        scale = Math.max(0.1, Math.min(scale, 3)); // Limit zoom range between 0.1x and 3x

        // Apply scale transform
        mindMap.style.transform = `scale(${scale})`;
    }

    let panning = false;
    let panStartX = 0;
    let panStartY = 0;
    let offsetX = 0;
    let offsetY = 0;

    const mindMapContainer = document.getElementById('mindMapContainer');
    //const mindMap = document.getElementById('mindMap');

    mindMapContainer.addEventListener('mousedown', function (event) {
        panning = true;
        panStartX = event.clientX;
        panStartY = event.clientY;
    });

    window.addEventListener('mouseup', function () {
        panning = false;
    });

    mindMapContainer.addEventListener('mousemove', function (event) {
        if (panning) {
            const dx = event.clientX - panStartX;
            const dy = event.clientY - panStartY;

            // Update the offsets with boundaries
            offsetX = Math.min(Math.max(offsetX + dx, -(mindMap.offsetWidth - mindMapContainer.offsetWidth)), 0);
            offsetY = Math.min(Math.max(offsetY + dy, -(mindMap.offsetHeight - mindMapContainer.offsetHeight)), 0);

            panStartX = event.clientX;
            panStartY = event.clientY;

            mindMap.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
        }
    });

    window.addEventListener('load', () => {
        // Center the mind map initially
        offsetX = -(mindMap.offsetWidth - mindMapContainer.offsetWidth) / 2;
        offsetY = -(mindMap.offsetHeight - mindMapContainer.offsetHeight) / 2;
        mindMap.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
    });
</script>
</body>

</html>